# frozen_string_literal: true

# Table: transactions
# Columns:
#  id                       | integer                     | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  portfolio_id             | integer                     | NOT NULL
#  account_id               | integer                     | NOT NULL
#  platform_transaction_id  | text                        | NOT NULL
#  from_wallet_id           | integer                     |
#  to_wallet_id             | integer                     |
#  from_currency_id         | integer                     | NOT NULL
#  to_currency_id           | integer                     | NOT NULL
#  fee_currency_id          | integer                     |
#  market_value_currency_id | integer                     |
#  from_amount              | numeric                     |
#  to_amount                | numeric                     |
#  market_value             | numeric                     |
#  fee                      | numeric                     |
#  type                     | transaction_type            | NOT NULL
#  processed                | boolean                     | NOT NULL DEFAULT false
#  completed_at             | timestamp without time zone | NOT NULL
#  created_at               | timestamp without time zone | NOT NULL
#  updated_at               | timestamp without time zone | NOT NULL
# Indexes:
#  transactions_pkey                                         | PRIMARY KEY btree (id)
#  transactions_account_id_type_platform_transaction_id_key  | UNIQUE btree (account_id, type, platform_transaction_id)
#  transactions_account_id_completed_at_type_index           | btree (account_id, completed_at, type)
#  transactions_account_id_from_currency_id_index            | btree (account_id, from_currency_id)
#  transactions_account_id_platform_transaction_id_index     | btree (account_id, platform_transaction_id)
#  transactions_account_id_processed_completed_at_type_index | btree (account_id, processed, completed_at, type)
#  transactions_account_id_processed_type_completed_at_index | btree (account_id, processed, type, completed_at)
#  transactions_account_id_to_currency_id_index              | btree (account_id, to_currency_id)
#  transactions_account_id_type_completed_at_index           | btree (account_id, type, completed_at)
#  transactions_account_id_type_from_currency_id_index       | btree (account_id, type, from_currency_id)
#  transactions_account_id_type_to_currency_id_index         | btree (account_id, type, to_currency_id)
#  transactions_created_at_index                             | btree (created_at)
#  transactions_from_wallet_id_index                         | btree (from_wallet_id)
#  transactions_portfolio_id_completed_at_type_index         | btree (portfolio_id, completed_at, type)
#  transactions_to_wallet_id_index                           | btree (to_wallet_id)
# Foreign key constraints:
#  transactions_account_id_fkey   | (account_id) REFERENCES accounts(id)
#  transactions_portfolio_id_fkey | (portfolio_id) REFERENCES portfolios(id)

class Transaction < Sequel::Model
  many_to_one :portfolio
  many_to_one :account
  many_to_one :from_currency, class: :Currency
  many_to_one :to_currency, class: :Currency
  many_to_one :fee_currency, class: :Currency
  many_to_one :market_value_currency, class: :Currency
  many_to_one :from_wallet, class: :Wallet
  many_to_one :to_wallet, class: :Wallet

  TABLE_HEADERS = [
    'id', 'type', 'platform_transaction_id',
    'from_amount', ' ', 'to_amount', ' ',
    'market_value', ' ', 'fee', ' ',
    'completed_at', 'processed'
  ].freeze
  TABLE_ALIGNMENTS = %i[left right left right left right left right left right left left center].freeze
  extend TableFormatter

  def before_validation
    self.portfolio_id = account.portfolio_id if portfolio_id.nil?
    super
  end

  def process!
    case type
    when 'buy'
      process_acquisition!
      update(processed: true)
    when 'sell'
      process_disposal!
      update(processed: true)
    when 'exchange'
      process_disposal!
      process_acquisition!
      update(processed: true)
    end
  end

  def table_row
    [
      id,
      type,
      platform_transaction_id,
      from_amount.to_s('F'),
      from_currency.symbol,
      to_amount.to_s('F'),
      to_currency.symbol,
      market_value&.to_s('F'),
      market_value_currency&.symbol,
      fee&.to_s('F'),
      fee_currency&.symbol,
      completed_at ? completed_at.strftime('%Y-%m-%d %H:%M:%S') : '',
      processed
    ]
  end

  def set_amount!(currency, amount)
    if amount.negative?
      self.from_currency = currency
      self.from_amount = amount
    else
      self.to_currency = currency
      self.to_amount = amount
    end
  end

  def classify_trade!
    self.type = classify_trade
  end

  def classify_trade
    return nil unless from_currency && to_currency
    return nil unless from_amount&.negative? && to_amount&.positive?

    return 'exchange' if from_currency.crypto? && to_currency.crypto?
    return 'buy' if from_currency.fiat? && to_currency.crypto?
    return 'sell' if from_currency.crypto? && to_currency.fiat?

    nil
  end

  private

  def process_acquisition!
    return if type == 'exchange' && market_value.nil?

    if from_currency.crypto? # exchange
      cost_currency = market_value_currency
      cost_amount = market_value
      # add fee to cost
      cost_amount += (market_value / from_amount.abs) * fee.abs if fee
    else # buy
      cost_currency = from_currency
      cost_amount = from_amount.abs
      cost_amount += fee.abs if fee
    end

    Acquisition.create(
      transaction: self,
      account:,
      currency: to_currency,
      amount: to_amount,
      cost_currency:,
      cost_amount:,
      type:,
      acquired_at: completed_at
    )
  end

  def process_disposal!
    disposed_amount = from_amount.abs # crypto
    if to_currency.crypto?
      # "exchange" type
      #   to_amount is crypto
      #   market_value contains the fiat value, but does not include the fee
      #   fee is denominated in crypto
      fiat_currency = market_value_currency
      fiat_amount = market_value
      if fee
        fee_amount = fee.abs
        fiat_amount += (market_value / disposed_amount) * fee_amount
        disposed_amount += fee_amount # fee is also being disposed
      end
    else
      # "sell" type
      #  to_amount contains fiat value
      #  fee is fiat & negative
      fiat_currency = to_currency
      # selling into fiat, so we need to deduct the fee
      fiat_amount = to_amount + (fee || 0)
    end

    fiat_price = fiat_amount / disposed_amount

    assets = Asset.disposal_lots(account:, currency: from_currency, amount: disposed_amount, disposed_at: completed_at)

    assets.each do |asset|
      if disposed_amount >= asset.amount
        amount = asset.amount
        cost_amount = asset.cost_amount
        disposed_amount -= amount
      else
        # partial disposal
        amount = disposed_amount.abs
        cost_amount = amount * asset.average_cost_amount
      end

      sold_amount = fiat_price * amount

      Disposal.create(
        portfolio:,
        account:,
        transaction: self,
        currency: from_currency,
        fiat_currency:,
        amount:,
        cost_amount:,
        sold_amount:,
        type:,
        acquisition: asset.acquisition,
        disposed_at: completed_at
      )
      asset.update(
        amount: asset.amount - amount,
        cost_amount: asset.cost_amount - cost_amount
      )
    end
  end
end
